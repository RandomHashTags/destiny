
import DestinyBlueprint
import DestinyDefaults
import SwiftSyntax
import SwiftSyntaxMacros

public struct RouterStorage {
    let context:MacroExpansionContext
    let settings:RouterSettings
    let perfectHashSettings:PerfectHashSettings
    var generatedDecls:[any DeclSyntaxProtocol] = []

    var autoGeneratedDynamicRespondersIndex = 0
    var autoGeneratedCaseSensitiveRespondersIndex = 0
    var autoGeneratedCaseInsensitiveRespondersIndex = 0
    var upgradeExistentialDynamicMiddleware:[FunctionCallExprSyntax] = []

    var dynamicMiddleware:[FunctionCallExprSyntax] = []
    var dynamicRedirects:[(any RedirectionRouteProtocol, SyntaxProtocol)] = []
    var dynamicCaseInsensitiveRoutes:[(DynamicRoute, FunctionCallExprSyntax)] = []
    var dynamicCaseSensitiveRoutes:[(DynamicRoute, FunctionCallExprSyntax)] = []

    var staticMiddleware:[CompiledStaticMiddleware] = []
    var staticRedirects:[(any RedirectionRouteProtocol, SyntaxProtocol)] = []
    var staticCaseInsensitiveRoutes:[(StaticRoute, FunctionCallExprSyntax)] = []
    var staticCaseSensitiveRoutes:[(StaticRoute, FunctionCallExprSyntax)] = []

    var routeGroups:[any DeclSyntaxProtocol] = []

    var conditionalResponders:[RoutePath:any ConditionalRouteResponderProtocol] = [:]
    var registeredPaths:Set<String> = []

    lazy var autoGeneratedOpaqueDynamicMiddleware: String? = {
        guard !upgradeExistentialDynamicMiddleware.isEmpty else { return nil }
        for (i, function) in upgradeExistentialDynamicMiddleware.enumerated() {
            let functionString = "\(function.arguments.first!.expression.as(ClosureExprSyntax.self)!.statements)"
            let name = "OpaqueDynamicMiddleware\(i)"
            let decl = try! StructDeclSyntax.init(.init(stringLiteral: """
            // MARK: \(name)
            \(visibility)struct \(name): OpaqueDynamicMiddlewareProtocol {

                \(inlinableAnnotation)
                \(visibility)func customLogic(
                    request: inout some HTTPRequestProtocol & ~Copyable,
                    response: inout some DynamicResponseProtocol
                ) throws(MiddlewareError) {
                    do { // TODO: use typed throw
                        \(functionString)
                    } catch {
                        throw .init(identifier: "\(name)HandleError", reason: "\\(error)")
                    }
                }

                \(inlinableAnnotation)
                \(visibility)func handle(
                    request: inout some HTTPRequestProtocol & ~Copyable,
                    response: inout some DynamicResponseProtocol
                ) throws(MiddlewareError) -> Bool {
                    try customLogic(request: &request, response: &response)
                    return true
                }
            }
            """))
            generatedDecls.append(decl)
        }
        return ""
    }()

    var visibility: RouterVisibility {
        settings.visibility
    }

    let visibilityModifier:DeclModifierSyntax

    func routerParameter(isCopyable: Bool) -> String {
        if isCopyable {
            return "some HTTPRouterProtocol"
        } else {
            return "borrowing some NonCopyableHTTPRouterProtocol & ~Copyable"
        }
    }

    static func responderParameter(copyable: Bool, dynamic: Bool) -> String {
        let name = dynamic ? "Dynamic" : "Static"
        if copyable {
            return "some \(name)RouteResponderProtocol"
        } else {
            return "borrowing some NonCopyable\(name)RouteResponderProtocol & ~Copyable"
        }
    }
}

// MARK: Initializer
extension RouterStorage {
    init(
        context: MacroExpansionContext,
        settings: RouterSettings,
        perfectHashSettings: PerfectHashSettings
    ) {
        self.context = context
        self.settings = settings
        self.perfectHashSettings = perfectHashSettings

        visibilityModifier = switch settings.visibility {
            case .public: .init(name: .keyword(.public))
            case .package: .init(name: .keyword(.package))
            case .internal: .init(name: .keyword(.internal))
            case .fileprivate: .init(name: .keyword(.fileprivate))
            case .private: .init(name: .keyword(.private))
        }
    }
}

// MARK: Misc

extension RouterStorage {
    mutating func routeGroupsString() -> String {
        var string = ""
        if !routeGroups.isEmpty {
            string += "\n" + routeGroups.map({ "\($0)" }).joined(separator: ",\n") + "\n"
        }
        return string
    }

    func staticMiddlewareString() -> String {
        return staticMiddleware.isEmpty ? "" : "\n" + staticMiddleware.map({ "\($0)" }).joined(separator: ",\n") + "\n"
    }

    mutating func dynamicMiddlewareArray() -> [String] {
        var array = [String]()
        if autoGeneratedOpaqueDynamicMiddleware != nil {
            array.append(contentsOf: upgradeExistentialDynamicMiddleware.enumerated().map({ "OpaqueDynamicMiddleware\($0.offset)()" }))
        }
        if !dynamicMiddleware.isEmpty {
            array.append(contentsOf: dynamicMiddleware.map({ "\($0)" }))
        }
        return array
    }
}

// MARK: Conditional responders string
extension RouterStorage {
    func conditionalRespondersString() -> String {
        var string:String
        if conditionalResponders.isEmpty {
            string = ":"
        } else {
            string = ""
            for (routePath, route) in conditionalResponders {
                string += "\n\(routePath.comment)\n\(routePath.path) : \(route.debugDescription),"
            }
            string.removeLast()
            string += "\n"
        }
        return string
    }
}

// MARK: Route
extension RouterStorage {
    struct Route {
        let startLine:String
        let buffer:SIMD64<UInt8>
        let responder:String

        var path: Substring {
            startLine.split(separator: " ")[1]
        }
        var paths: [Substring] {
            path.split(separator: "/")
        }
    }
}