
import DestinyBlueprint
import DestinyDefaults
import SwiftSyntax
import SwiftSyntaxMacros

public struct RouterStorage {
    let settings:RouterSettings
    let perfectHashSettings:PerfectHashSettings
    var generatedDecls:[any DeclSyntaxProtocol] = []

    var autoGeneratedDynamicRespondersIndex = 0
    var autoGeneratedCaseSensitiveRespondersIndex = 0
    var autoGeneratedCaseInsensitiveRespondersIndex = 0
    var upgradeExistentialDynamicMiddleware:[FunctionCallExprSyntax] = []

    var dynamicMiddleware:[FunctionCallExprSyntax] = []
    var dynamicRedirects:[(any RedirectionRouteProtocol, SyntaxProtocol)] = []
    var dynamicCaseInsensitiveRoutes:[(DynamicRoute, FunctionCallExprSyntax)] = []
    var dynamicCaseSensitiveRoutes:[(DynamicRoute, FunctionCallExprSyntax)] = []

    var staticMiddleware:[CompiledStaticMiddleware] = []
    var staticRedirects:[(any RedirectionRouteProtocol, SyntaxProtocol)] = []
    var staticCaseInsensitiveRoutes:[(StaticRoute, FunctionCallExprSyntax)] = []
    var staticCaseSensitiveRoutes:[(StaticRoute, FunctionCallExprSyntax)] = []

    var routeGroups:[any DeclSyntaxProtocol] = []

    var conditionalResponders:[RoutePath:any ConditionalRouteResponderProtocol] = [:]
    var registeredPaths:Set<String> = []

    lazy var autoGeneratedOpaqueDynamicMiddleware: String? = {
        guard !upgradeExistentialDynamicMiddleware.isEmpty else { return nil }
        for (i, function) in upgradeExistentialDynamicMiddleware.enumerated() {
            let functionString = "\(function.arguments.first!.expression.as(ClosureExprSyntax.self)!.statements)"
            let name = "OpaqueDynamicMiddleware\(i)"
            let string = """
            // MARK: \(name)
            \(visibility)struct \(name): OpaqueDynamicMiddlewareProtocol {

                \(inlinableAnnotation)
                \(visibility)func customLogic(
                    request: inout some HTTPRequestProtocol & ~Copyable,
                    response: inout some DynamicResponseProtocol
                ) throws(MiddlewareError) {
                    do { // TODO: use typed throw
                        \(functionString)
                    } catch {
                        throw .init(identifier: "\(name)HandleError", reason: "\\(error)")
                    }
                }

                \(inlinableAnnotation)
                \(visibility)func handle(
                    request: inout some HTTPRequestProtocol & ~Copyable,
                    response: inout some DynamicResponseProtocol
                ) throws(MiddlewareError) -> Bool {
                    try customLogic(request: &request, response: &response)
                    return true
                }
            }
            """
            try! generatedDecls.append(StructDeclSyntax(.init(stringLiteral: string)))
        }
        return ""
    }()

    var visibility: RouterVisibility {
        settings.visibility
    }

    

    func routerParameter(isCopyable: Bool) -> String {
        if isCopyable {
            return "some HTTPRouterProtocol"
        } else {
            return "borrowing some NonCopyableHTTPRouterProtocol & ~Copyable"
        }
    }

    static func responderParameter(copyable: Bool, dynamic: Bool) -> String {
        let name = dynamic ? "Dynamic" : "Static"
        if copyable {
            return "some \(name)RouteResponderProtocol"
        } else {
            return "borrowing some NonCopyable\(name)RouteResponderProtocol & ~Copyable"
        }
    }
}

extension RouterStorage {
    mutating func routeGroupsString(context: some MacroExpansionContext) -> String {
        var string = ""
        if !routeGroups.isEmpty {
            string += "\n" + routeGroups.map({ "\($0)" }).joined(separator: ",\n") + "\n"
        }
        return string
    }

    func staticMiddlewareString() -> String {
        return staticMiddleware.isEmpty ? "" : "\n" + staticMiddleware.map({ "\($0)" }).joined(separator: ",\n") + "\n"
    }

    mutating func dynamicMiddlewareArray(mutable: Bool) -> [String] {
        var array = [String]()
        if autoGeneratedOpaqueDynamicMiddleware != nil {
            array.append(contentsOf: upgradeExistentialDynamicMiddleware.enumerated().map({ "OpaqueDynamicMiddleware\($0.offset)()" }))
        }
        if !dynamicMiddleware.isEmpty {
            array.append(contentsOf: dynamicMiddleware.map({ "\($0)" }))
        }
        return array
    }

    mutating func staticResponsesSyntax(
        mutable: Bool,
        context: some MacroExpansionContext,
        isCaseSensitive: Bool
    ) -> (copyable: String?, noncopyable: String?)? {
        var possibleRemovedRedirects = Set<String>() // TODO: fix
        let targetRedirects:[(any RedirectionRouteProtocol, SyntaxProtocol)] = staticRedirects.enumerated().compactMap({
            guard $0.element.0.isCaseSensitive == isCaseSensitive else { return nil }
            possibleRemovedRedirects.insert($0.element.0.fromStartLine())
            return $0.element
        })
        var redirects = targetRedirects
        let result = staticRoutesSyntax(
            mutable: mutable,
            context: context,
            isCaseSensitive: isCaseSensitive,
            redirects: &redirects,
            middleware: staticMiddleware,
            routes: isCaseSensitive ? staticCaseSensitiveRoutes : staticCaseInsensitiveRoutes
        )
        if targetRedirects.count != redirects.count {
            for i in stride(from: targetRedirects.count-1, through: 0, by: -1) {
                if possibleRemovedRedirects.contains(targetRedirects[i].0.fromStartLine()) {
                    staticRedirects.remove(at: i)
                }
            }
        }
        return result
    }
}

// MARK: Dynamic responses string
extension RouterStorage {
    mutating func dynamicResponsesString(
        mutable: Bool,
        context: some MacroExpansionContext,
        isCaseSensitive: Bool
    ) -> (copyable: String?, noncopyable: String?)? {
        let routes = isCaseSensitive ? dynamicCaseSensitiveRoutes : dynamicCaseInsensitiveRoutes
        let copyable:String?
        let noncopyable:String?
        if let responders = dynamicRoutesSyntax(
            mutable: mutable,
            context: context,
            isCaseSensitive: isCaseSensitive,
            isCopyable: true,
            routes: routes
        ) {
            copyable = decl(isCaseSensitive: isCaseSensitive, isCopyable: true, responders: responders).name.text + "()"
        } else {
            copyable = nil
        }
        if let responders = dynamicRoutesSyntax(
            mutable: mutable,
            context: context,
            isCaseSensitive: isCaseSensitive,
            isCopyable: false,
            routes: routes
        ) {
            noncopyable = decl(isCaseSensitive: isCaseSensitive, isCopyable: false, responders: responders).name.text + "()"
        } else {
            noncopyable = nil
        }
        return copyable != nil || noncopyable != nil ? (copyable, noncopyable) : nil
    }

    private mutating func decl(
        isCaseSensitive: Bool,
        isCopyable: Bool,
        responders: [(path: SIMD64<UInt8>, responder: String)]
    ) -> StructDeclSyntax {
        let name = "Case\(isCaseSensitive ? "S" : "Ins")ensitiveResponderStorage\(isCaseSensitive ? autoGeneratedCaseSensitiveRespondersIndex : autoGeneratedCaseInsensitiveRespondersIndex)"
        var decl = StructDeclSyntax.init(
            leadingTrivia: "// MARK: \(name)\n\(visibility)",
            name: "\(raw: name)",
            inheritanceClause: .init(inheritedTypes: .init(arrayLiteral:
                .init(type: TypeSyntax("\(raw: isCopyable ? "" : "NonCopyable")ResponderStorageProtocol"), trailingComma: ","),
                .init(type: TypeSyntax("\(raw: isCopyable ? "" : "~")Copyable"))
            )),
            memberBlock: .init(members: .init())
        )
        var entryDecl = StructDeclSyntax(
            leadingTrivia: "\(visibility)",
            name: "Entry",
            genericParameterClause: .init(parameters: .init(arrayLiteral:
                .init(name: "ConcreteResponder", colon: ":", inheritedType: TypeSyntax("\(raw: isCopyable ? "" : "NonCopyable")DynamicRouteResponderProtocol\(raw: isCopyable ? "" : " & ~Copyable")"))
            )),
            inheritanceClause: .init(inheritedTypes: .init(arrayLiteral:
                .init(type: TypeSyntax("\(raw: isCopyable ? "" : "~")Copyable"))
            )),
            memberBlock: .init(members: .init())
        )
        entryDecl.memberBlock.members.append(.init(decl: VariableDeclSyntax(leadingTrivia: "\n", .let, name: "path", type: .init(type: TypeSyntax("SIMD64<UInt8>")))))
        entryDecl.memberBlock.members.append(.init(decl: VariableDeclSyntax(leadingTrivia: "\n", .let, name: "responder", type: .init(type: TypeSyntax("ConcreteResponder")))))
        for (index, (path, responder)) in responders.enumerated() {
            try! decl.memberBlock.members.append(.init(decl: VariableDeclSyntax.init("""
            \(raw: visibility)let route\(raw: index) = Entry(path: \(raw: path), responder: \(raw: responder))
            """)))
        }
        let respondedDecl = try! FunctionDeclSyntax("""
        \(raw: inlinableAnnotation)
        \(raw: visibility)func responded(
            router: \(raw: routerParameter(isCopyable: isCopyable)),
            socket: some FileDescriptor,
            request: inout some HTTPRequestProtocol & ~Copyable,
            requestPathCount: Int,
            requestStartLine: SIMD64<UInt8>,
            completionHandler: @Sendable @escaping () -> Void
        ) throws(ResponderError) -> Bool {
            if path == requestStartLine { // parameterless
                try router.respond(socket: socket, request: &request, responder: responder, completionHandler: completionHandler)
                return true
            } else { // parameterized and catchall
                let pathComponentsCount = responder.pathComponentsCount
                var found = true
                var lastIsCatchall = false
                var lastIsParameter = false
                loop: for i in 0..<pathComponentsCount {
                    let path = responder.pathComponent(at: i)
                    switch path {
                    case .catchall:
                        lastIsCatchall = true
                        lastIsParameter = false
                        break loop
                    case .literal(let l):
                        lastIsCatchall = false
                        lastIsParameter = false
                        if requestPathCount <= i {
                            found = false
                            break loop
                        } else {
                            do throws(SocketError) {
                                let pathAtIndex = try request.path(at: i)
                                if l != pathAtIndex {
                                    found = false
                                    break loop
                                }
                            } catch {
                                throw .socketError(error)
                            }
                        }
                    case .parameter:
                        lastIsCatchall = false
                        lastIsParameter = true
                    }
                }
                if found && (lastIsCatchall || lastIsParameter && requestPathCount == pathComponentsCount) {
                    try router.respond(socket: socket, request: &request, responder: responder, completionHandler: completionHandler)
                    return true
                }
                return false
            }
        }
        """)
        entryDecl.memberBlock.members.append(.init(decl: respondedDecl))
        decl.memberBlock.members.append(.init(decl: entryDecl))

        var respondersString = responders.enumerated().map({ index, _ in
            "if try route\(index).responded(router: router, socket: socket, request: &request, requestPathCount: requestPathCount, requestStartLine: requestStartLine, completionHandler: completionHandler) {\nreturn true\n"
        }).joined(separator: "} else ")
        if !responders.isEmpty {
            respondersString += "}"
        }
        let respondDecl = try! FunctionDeclSyntax("""
        \(raw: inlinableAnnotation)
        \(raw: visibility)func respond(
            router: \(raw: routerParameter(isCopyable: isCopyable)),
            socket: some FileDescriptor,
            request: inout some HTTPRequestProtocol & ~Copyable,
            completionHandler: @Sendable @escaping () -> Void
        ) throws(ResponderError) -> Bool {
            let requestPathCount:Int
            let requestStartLine:SIMD64<UInt8>
            do throws(SocketError) {
                requestPathCount = try request.pathCount()
                requestStartLine = try request.startLine()
            } catch {
                throw .socketError(error)
            }
            \(raw: respondersString)
            return false
        }
        """)
        decl.memberBlock.members.append(.init(decl: respondDecl))
        generatedDecls.append(decl)
        if isCaseSensitive {
            autoGeneratedCaseSensitiveRespondersIndex += 1
        } else {
            autoGeneratedCaseInsensitiveRespondersIndex += 1
        }
        return decl
    }
}

// MARK: Conditional responders string
extension RouterStorage {
    func conditionalRespondersString() -> String {
        var string:String
        if conditionalResponders.isEmpty {
            string = ":"
        } else {
            string = ""
            for (routePath, route) in conditionalResponders {
                string += "\n\(routePath.comment)\n\(routePath.path) : \(route.debugDescription),"
            }
            string.removeLast()
            string += "\n"
        }
        return string
    }
}

// MARK: Route
extension RouterStorage {
    struct Route {
        let startLine:String
        let buffer:SIMD64<UInt8>
        let responder:String

        var path: Substring {
            startLine.split(separator: " ")[1]
        }
        var paths: [Substring] {
            path.split(separator: "/")
        }
    }
}