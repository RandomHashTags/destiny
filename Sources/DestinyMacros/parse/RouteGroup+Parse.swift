
import DestinyBlueprint
import DestinyDefaults
import SwiftSyntax
import SwiftSyntaxMacros

extension RouteGroup {
    /// Parsing logic for this router group.
    /// 
    /// - Parameters:
    ///   - context: The macro expansion context.
    ///   - version: The `HTTPVersion` of the router this router group belongs to.
    ///   - staticMiddleware: The static middleware of the router this router group belongs to.
    ///   - dynamicMiddleware: The dynamic middleware of the router this router group belongs to.
    ///   - function: SwiftSyntax expression that represents this router group at compile time.
    public static func parse(
        context: some MacroExpansionContext,
        version: HTTPVersion,
        staticMiddleware: [CompiledStaticMiddleware],
        dynamicMiddleware: [FunctionCallExprSyntax],
        autoGeneratedDynamicRespondersIndex: inout Int,
        _ function: FunctionCallExprSyntax
    ) -> (decl: DeclSyntax, storage: RouterStorage) {
        var storage = RouterStorage()
        storage.autoGeneratedDynamicRespondersIndex = autoGeneratedDynamicRespondersIndex
        storage.staticMiddleware = staticMiddleware

        var endpoint = ""
        var conditionalResponders = [DestinyRoutePathType:any ConditionalRouteResponderProtocol]()
        for f in dynamicMiddleware {
            Router.parseDynamicMiddleware(context: context, function: f, storage: &storage)
        }
        
        for arg in function.arguments {
            if let label = arg.label?.text {
                switch label {
                case "endpoint":
                    guard let string = arg.expression.stringLiteralString(context: context) else { break }
                    endpoint = string
                case "staticMiddleware":
                    guard let array = arg.expression.arrayElements(context: context) else { break }
                    for arg in array {
                        if let function = arg.expression.functionCall {
                            Router.parseStaticMiddleware(context: context, function: function, storage: &storage)
                        }
                    }
                case "dynamicMiddleware":
                    guard let array = arg.expression.arrayElements(context: context) else { break }
                    for arg in array {
                        if let function = arg.expression.functionCall {
                            Router.parseDynamicMiddleware(context: context, function: function, storage: &storage)
                        }
                    }
                default:
                    context.diagnose(DiagnosticMsg.unhandled(node: arg))
                }
            } else if let function = arg.expression.functionCall {
                Router.parseRoute(context: context, version: version, function: function, storage: &storage)
            }
        }

        let prefixEndpoints = endpoint.split(separator: "/").map({ String($0) })
        let pathComponents = prefixEndpoints.map({ PathComponent.literal($0) })

        let staticMiddlewareString = staticMiddleware.map({ "\($0)" }).joined(separator: ",\n")
        let dynamicMiddlewareString = storage.dynamicMiddleware.map({ "\($0)" }).joined(separator: ",\n")

        let immutableStaticMiddlewareSyntax:String
        if staticMiddleware.isEmpty {
            immutableStaticMiddlewareSyntax = "Optional<CompiledStaticMiddlewareStorage<StaticMiddleware>>.none"
        } else {
            immutableStaticMiddlewareSyntax = "CompiledStaticMiddlewareStorage((\n\(staticMiddlewareString)\n))"
        }

        let immutableDynamicMiddlewareSyntax:String
        if storage.dynamicMiddleware.isEmpty {
            immutableDynamicMiddlewareSyntax = "Optional<CompiledDynamicMiddlewareStorage<DynamicMiddleware>>.none"
        } else {
            immutableDynamicMiddlewareSyntax = "CompiledDynamicMiddlewareStorage((\n\(dynamicMiddlewareString)\n))"
        }

        for i in storage.staticRoutes.indices {
            var (route, function) = storage.staticRoutes[i]
            route.insertPath(contentsOf: prefixEndpoints, at: 0)
            storage.staticRoutes[i] = (route, function)
        }
        let staticRespondersSyntax = storage.staticRoutesSyntax(
            mutable: false,
            context: context,
            isCaseSensitive: true,
            redirects: storage.staticRedirects,
            middleware: storage.staticMiddleware,
            routes: storage.staticRoutes
        )

        for i in storage.dynamicRoutes.indices {
            var (route, function) = storage.dynamicRoutes[i]
            route.insertPath(contentsOf: pathComponents, at: 0)
            storage.dynamicRoutes[i] = (route, function)
        }
        let dynamicRespondersSyntax = storage.dynamicRoutesSyntax(
            mutable: false,
            context: context,
            isCaseSensitive: true,
            routes: storage.dynamicRoutes
        )

        let compiled = """
        CompiledRouteGroup(
            prefixEndpoints: \(prefixEndpoints),
            immutableStaticMiddleware: \(immutableStaticMiddlewareSyntax),
            immutableDynamicMiddleware: \(immutableDynamicMiddlewareSyntax),
            immutableStaticResponders: \(staticRespondersSyntax),
            immutableDynamicResponders: \(dynamicRespondersSyntax),
            mutableStaticResponders: StaticResponderStorage(),
            mutableDynamicResponders: DynamicResponderStorage()
        )
        """

        autoGeneratedDynamicRespondersIndex = storage.autoGeneratedDynamicRespondersIndex
        return (DeclSyntax(stringLiteral: compiled), storage)
    }
}