
import DestinyBlueprint
import DestinyDefaults
import SwiftDiagnostics
import SwiftSyntax
import SwiftSyntaxMacros

// MARK: Static routes string
extension RouterStorage {
    mutating func staticRoutesSyntax(
        mutable: Bool,
        context: some MacroExpansionContext,
        isCaseSensitive: Bool,
        redirects: [(any RedirectionRouteProtocol, SyntaxProtocol)],
        middleware: [CompiledStaticMiddleware],
        routes: [(StaticRoute, FunctionCallExprSyntax)]
    ) -> String? {
        guard !routes.isEmpty else { return nil }
        var routePaths = [String]()
        var literalRouteResponders = [String]()
        var routeResponders = [String]()
        routePaths.reserveCapacity(routes.count)
        literalRouteResponders.reserveCapacity(routes.count)
        routeResponders.reserveCapacity(routes.count)
        let getResponderValue:(RouterStorage.Route) -> String = {
            let responder = $0.responder
            return "// \($0.startLine)\nCompiledStaticResponderStorageRoute(\npath: \($0.buffer),\nresponder: \(responder)\n)"
        }

        let random:Int
        let namePrefix:String
        let getRedirectRouteStartLine:(any RedirectionRouteProtocol) -> String
        if isCaseSensitive {
            random = autoGeneratedCaseSensitiveRespondersIndex
            namePrefix = "CaseSensitive"
            getRedirectRouteStartLine = { $0.fromStartLine() }
        } else {
            random = autoGeneratedCaseInsensitiveRespondersIndex
            namePrefix = "CaseInsensitive"
            getRedirectRouteStartLine = { $0.fromStartLine().lowercased() }
        }
        
        if !redirects.isEmpty {
            for (route, function) in redirects {
                var string = getRedirectRouteStartLine(route)
                if registeredPaths.contains(string) {
                    Router.routePathAlreadyRegistered(context: context, node: function, string)
                } else {
                    registeredPaths.insert(string)
                    do throws(AnyError) {
                        let responder = try IntermediateResponseBody(
                            type: .stringWithDateHeader,
                            ""
                        ).responderDebugDescription(settings: settings, response: route.response())
                        routeResponders.append(getResponderValue(.init(startLine: string, buffer: .init(&string), responder: responder)))
                        routePaths.append("\(string)")
                        literalRouteResponders.append(responder)
                    } catch {
                        context.diagnose(Diagnostic(node: function, message: DiagnosticMsg(id: "staticRedirectError", message: "\(error)")))
                    }
                }
            }
        }
        appendStaticRoutes(
            context: context,
            middleware: middleware,
            isCaseSensitive: isCaseSensitive,
            routes: routes,
            literalRoutePaths: &routePaths,
            routeResponders: &routeResponders,
            literalRouteResponders: &literalRouteResponders
        )

        var enumDecl = StructDeclSyntax(
            leadingTrivia: "// MARK: \(namePrefix)StaticResponderStorage\(random)\n\(visibility)",
            name: "\(raw: namePrefix)StaticResponderStorage\(raw: random)",
            inheritanceClause: .init(
                inheritedTypes: .init(arrayLiteral:
                    .init(type: TypeSyntax.init(stringLiteral: "StaticResponderStorageProtocol"), trailingComma: ","),
                    .init(type: TypeSyntax.init(stringLiteral: "Copyable"))
                )
            ),
            memberBlock: .init(members: .init())
        )

        generatedDecls.append(enumDecl)    
        if isCaseSensitive {
            autoGeneratedCaseSensitiveRespondersIndex += 1
        } else {
            autoGeneratedCaseInsensitiveRespondersIndex += 1
        }
        return "\(enumDecl.name.text)()"
    }
    func responseBodyResponderDebugDescription(
        body: (any ResponseBodyProtocol)?,
        response: HTTPResponseMessage
    ) throws(HTTPMessageError) -> String? {
        guard let body else { return nil }
        let s:String?
        if let v = body as? String {
            s = try v.responderDebugDescription(response)
        } else if let v = body as? IntermediateResponseBody {
            s = v.responderDebugDescription(settings: settings, response: response)

        } else {
            s = nil
        }
        return s
    }
}