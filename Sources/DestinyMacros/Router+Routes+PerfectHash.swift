

import DestinyBlueprint
import DestinyDefaults
import PerfectHashing
import SwiftDiagnostics
import SwiftSyntax
import SwiftSyntaxMacros

#if NonEmbedded
import DestinyDefaultsNonEmbedded
#endif

extension RouterStorage {
    mutating func perfectHashResponder(
        isCaseSensitive: Bool
    ) -> CompiledRouterStorage.Responder? {
        #if NonEmbedded
        let namePrefix:String
        let staticRoutes:[(StaticRoute, FunctionCallExprSyntax)]
        if isCaseSensitive {
            namePrefix = "CaseSensitive"
            staticRoutes = staticRouteStorage.caseSensitiveRoutes
        } else {
            namePrefix = "CaseInsensitive"
            staticRoutes = staticRouteStorage.caseInsensitiveRoutes
        }
        let copyable:String?
        var noncopyable:String? = nil
        if let declName = perfectHashDeclName(
            namePrefix: namePrefix,
            random: getRandom(isCaseSensitive: isCaseSensitive),
            staticRoutes: staticRoutes,
            isCaseSensitive: isCaseSensitive,
            isCopyable: true
        ) {
            copyable = "\(declName)()"
        } else {
            copyable = nil
        }
        if let declName = perfectHashDeclName(
            namePrefix: namePrefix,
            random: getRandom(isCaseSensitive: isCaseSensitive),
            staticRoutes: staticRoutes,
            isCaseSensitive: isCaseSensitive,
            isCopyable: false
        ) {
            noncopyable = "\(declName)()"
        } else {
            noncopyable = nil
        }
        return .get(copyable, noncopyable)
        #else
        return nil
        #endif
    }
    private func getRandom(isCaseSensitive: Bool) -> Int {
        if isCaseSensitive {
            autoGeneratedCaseSensitiveRespondersIndex
        } else {
            autoGeneratedCaseInsensitiveRespondersIndex
        }
    }
}

// MARK: Decl
extension RouterStorage {
    #if NonEmbedded
    private mutating func perfectHashDeclName(
        namePrefix: String,
        random: Int,
        staticRoutes: [(StaticRoute, FunctionCallExprSyntax)],
        isCaseSensitive: Bool,
        isCopyable: Bool
    ) -> String? {
        var dynamicRoutesCount = 0
        #if NonEmbedded
        let dynamicRoutes = isCaseSensitive ? dynamicRouteStorage.caseSensitiveRoutes : dynamicRouteStorage.caseInsensitiveRoutes
        dynamicRoutesCount = dynamicRoutes.count
        #endif
        let reservedCapacity = staticRoutes.count + dynamicRoutesCount
        var routePaths = [String]()
        var routeResponders = [String]()
        routePaths.reserveCapacity(reservedCapacity)
        routeResponders.reserveCapacity(reservedCapacity)

        #if NonEmbedded
        appendStaticRoutes(
            isCaseSensitive: isCaseSensitive,
            isCopyable: isCopyable,
            routes: staticRoutes,
            routePaths: &routePaths,
            routeResponders: &routeResponders
        )
        appendDynamicRoutes(
            isCaseSensitive: isCaseSensitive,
            isCopyable: isCopyable,
            routes: dynamicRoutes,
            literalRoutePaths: &routePaths,
            routeResponders: &routeResponders
        )
        #endif

        guard !routePaths.isEmpty else { return nil }
        var members = MemberBlockItemListSyntax()
        staticConstants(
            isCaseSensitive: isCaseSensitive,
            isCopyable: isCopyable,
            routePaths: routePaths,
            members: &members,
            routeResponders: routeResponders
        )
        let name = "\(namePrefix)ResponderStorage\(random)"
        let compilationCondition = isCopyable ? "Copyable" : "NonCopyable"
        let enumDecl = StructDeclSyntax(
            leadingTrivia: "#if \(compilationCondition)\n// MARK: \(namePrefix)ResponderStorage\(random)\n",
            modifiers: [visibilityModifier],
            name: "\(raw: name)",
            inheritanceClause: .init(
                inheritedTypes: responderStorageProtocolConformances(isCopyable: isCopyable, protocolConformance: settings.hasProtocolConformances)
            ),
            memberBlock: .init(members: members),
            trailingTrivia: "\n#endif"
        )
        generatedDecls.append(enumDecl)
        if isCaseSensitive {
            autoGeneratedCaseSensitiveRespondersIndex += 1
        } else {
            autoGeneratedCaseInsensitiveRespondersIndex += 1
        }
        return name
    }
    #endif
}

// MARK: Static constants
extension RouterStorage {
    private func staticConstants(
        isCaseSensitive: Bool,
        isCopyable: Bool,
        routePaths: [String],
        members: inout MemberBlockItemListSyntax,
        routeResponders: [String]
    ) {
        let routerParameter = routerParameter(isCopyable: isCopyable, protocolConformances: hasProtocolConformances)
        var routePathCaseConditions = ""
        var routePathSIMDs = [SIMD64<UInt8>]()
        var staticResponders = [VariableDeclSyntax]()
        var staticSIMDs = [VariableDeclSyntax]()
        routePathSIMDs.reserveCapacity(routePaths.count)
        staticResponders.reserveCapacity(routePaths.count)
        staticSIMDs.reserveCapacity(routePaths.count)

        let responderBinding:Keyword
        let responderType:(String) -> TypeAnnotationSyntax?
        let responderInitializer:(String) -> InitializerClauseSyntax?
        let responderAccessor:(String) -> AccessorBlockSyntax?
        if respondersAreComputedProperties {
            responderBinding = .var
            responderType = {
                .init(type: TypeSyntax(stringLiteral: String($0.split(separator: "(").first!)))
            }
            responderInitializer = { _ in nil }
            responderAccessor = {
                .init(
                    leftBrace: .leftBraceToken(),
                    accessors: .getter(.init([
                        .init(stringLiteral: $0)
                    ])),
                    rightBrace: .rightBraceToken()
                )
            }
        } else {
            responderBinding = .let
            responderType = { _ in nil }
            responderInitializer = {
                .init(value: ExprSyntax(stringLiteral: $0))
            }
            responderAccessor = { _ in nil }
        }
        var routeMembers = MemberBlockItemListSyntax()
        for (index, routePath) in routePaths.enumerated() {
            let caseName = "`\(routePath)`"
            routePathCaseConditions += "\ncase .\(caseName):\ntry Self.responder\(index).respond(router: router, socket: socket, request: &request, completionHandler: completionHandler)"
            routeMembers.append(try! EnumCaseDeclSyntax.init("case \(raw: caseName)"))

            let utf8 = routePath.utf8
            var simd = SIMD64<UInt8>.zero
            let utf8Count = utf8.count
            if utf8Count > 0 {
                for i in 0..<min(simd.scalarCount, utf8Count) {
                    simd[i] = utf8[utf8.index(utf8.startIndex, offsetBy: i)]
                }
            }
            routePathSIMDs.append(simd)

            let responder = routeResponders[index]
            let responderDecl = VariableDeclSyntax.init(
                leadingTrivia: "/// Request: `\(routePath)`\n",
                modifiers: [visibilityModifier, .init(name: .keyword(.static))],
                responderBinding,
                name: "responder\(raw: index)",
                type: responderType(responder),
                initializer: responderInitializer(responder),
                accessorBlock: responderAccessor(responder)
            )
            staticResponders.append(responderDecl)

            let staticSIMD = VariableDeclSyntax.init(
                modifiers: [visibilityModifier, .init(name: .keyword(.static))],
                .let,
                name: "simd\(raw: index)",
                initializer: .init(value: ExprSyntax(stringLiteral: "\(simd)"))
            )
            staticSIMDs.append(staticSIMD)
        }

        let routeResponderDecl = try! FunctionDeclSyntax.init("""
        \(raw: inlinableAnnotation)
        \(raw: visibility)func respond(
            router: \(raw: routerParameter),
            socket: some FileDescriptor,
            request: \(requestTypeSyntax),
            completionHandler: @Sendable @escaping () -> Void
        ) throws(ResponderError) -> Bool {
            switch self {
            \(raw: routePathCaseConditions)
            }
            return true
        }
        """)
        routeMembers.append(routeResponderDecl)
        routeMembers.append(contentsOf: staticResponders.map({ .init(decl: $0) }))
        let routeConstantsDecl = EnumDeclSyntax(
            modifiers: [visibilityModifier],
            name: "Route",
            inheritanceClause: .init(inheritedTypes: .init([
                .init(type: TypeSyntax("UInt16"))
            ])),
            memberBlock: .init(members: routeMembers)
        )
        members.append(routeConstantsDecl)
        appendMatchRouteDecl(
            routePaths: routePaths,
            routePathSIMDs: routePathSIMDs,
            staticSIMDs: staticSIMDs,
            members: &members
        )
        appendRespondDecl(
            isCaseSensitive: isCaseSensitive,
            routerParameter: routerParameter,
            members: &members
        )
    }
}

// MARK: Append respond decl
extension RouterStorage {
    private func appendRespondDecl(
        isCaseSensitive: Bool,
        routerParameter: String,
        members: inout MemberBlockItemListSyntax
    ) {
        let decl = try! FunctionDeclSyntax.init("""
        \(raw: inlinableAnnotation)
        \(raw: visibility)func respond(
            router: \(raw: routerParameter),
            socket: some FileDescriptor,
            request: \(requestTypeSyntax),
            completionHandler: @Sendable @escaping () -> Void
        ) throws(ResponderError) -> Bool {
            let startLine:SIMD64<UInt8>
            do throws(SocketError) {
                startLine = try request.startLine\(raw: isCaseSensitive ? "" : "Lowercased")()
            } catch {
                throw .socketError(error)
            }
            guard let route = matchRoute(startLine) else { return false }
            return try route.respond(router: router, socket: socket, request: &request, completionHandler: completionHandler)
        }
        """)
        members.append(decl)
    }
}

// MARK: Append match route decl
extension RouterStorage {
    private func appendMatchRouteDecl(
        routePaths: [String],
        routePathSIMDs: [SIMD64<UInt8>],
        staticSIMDs: [VariableDeclSyntax],
        members: inout MemberBlockItemListSyntax
    ) {
        if perfectHashSettings.enabled {
            //let relaxedRoutePaths = routePaths.filter({ perfectHashSettings.relaxedRoutePaths.contains($0) }) // TODO: support
            let perfectHashableItems:[PerfectHashableItem<SIMD64<UInt8>>] = routePaths.enumerated().map({
                return .init($1, routePathSIMDs[$0])
            })
            let perfectHashPositions = PerfectHashGenerator.findPerfectHashPositions(routes: perfectHashableItems, maxBytes: perfectHashSettings.maxBytes.max()!)
            let hashSeeds:InlineArray<_, UInt64> = [
                0x9E3779B97F4A7C15,
                0xC6A4A7935D83A9C3,
                0x5555555555555555,
                0x1234567812345678,
                0x1F1F1F1F1F1F1F1F,
                0xFFFFFFFFFFFFFFFF,
                0x3141592653589793,
                0xDEADBEEFDEADBEEF,
                0xBADC0FFEBADC0FFE,
                0xCAFEBABECAFEBABE,
                0x0A0A0A0A0A0A0A0A,
                0x8000000080000000,
                0x1BADB0021BADB002,
                0xF00DF00DF00DF00D,
                0xBEAFBEAFBEAFBEAF,
                0x5A5A5A5A5A5A5A5A,
                0x8BADF00D8BADF00D,
                0xDEADD00DDEADD00D,
                0x1234ABCD1234ABCD,
                0x7F7F7F7F7F7F7F7F,
                0x2B2B2B2B2B2B2B2B,
                0x1E1E1E1E1E1E1E1E,
                0xA5A5A5A5A5A5A5A5,
                0x6C6C6C6C6C6C6C6C,
                0xF1F1F1F1F1F1F1F1,
                0x3C3C3C3C3C3C3C3C,
                0x8C8C8C8C8C8C8C8C,
                0xFEEDFACEFEEDFACE,
                0x1234123412341234,
                0x4567456745674567,
                0x9988776655443322,
                0xCDCDCDCDCDCDCDCD,
                0x1111111111111111,
                0x9999999999999999,
                0xDEEDDEEDDEEDDEED,
                0xFEEDBEEFFEEDBEEF,
                0xABCDEABCABCDEABC,
                0x5B5B5B5B5B5B5B5B,
                0x8001C8001C8001C8,
                0xD9D9D9D9D9D9D9D9,
                0x1112222333445555,
                0x9C9C9C9C9C9C9C9C,
                0xA8A8A8A8A8A8A8A8,
                0xE1E1E1E1E1E1E1E1,
                0x5D5D5D5D5D5D5D5D,
                0x4F4F4F4F4F4F4F4F,
                0xBABABABABABABABA,
                0x6E6E6E6E6E6E6E6E,
                0x7D7D7D7D7D7D7D7D,
                0x9F9F9F9F9F9F9F9F
            ]
            for hashBytes in perfectHashSettings.maxBytes {
                if let perfectHashDecls = matchRoutePerfectHashDecls(
                    routePaths: routePaths,
                    routePathSIMDs: perfectHashableItems,
                    perfectHashPositions: perfectHashPositions,
                    seeds: hashSeeds,
                    hashMaxBytes: hashBytes,
                    requireExactPaths: perfectHashSettings.requireExactPaths
                ) {
                    members.append(contentsOf: perfectHashDecls)
                    return
                }
            }
        }
        // perfect hash not found; fallback to default impl
        members.append(contentsOf: staticSIMDs.map({ .init(decl: $0) }))
        members.append(matchRouteFallbackDecl(routePaths: routePaths))
    }
}

// MARK: Match route
extension RouterStorage {
    private func matchRoutePerfectHashDecls<let count: Int>(
        routePaths: [String],
        routePathSIMDs: [PerfectHashableItem<SIMD64<UInt8>>],
        perfectHashPositions: InlineArray<64, Int>,
        seeds: InlineArray<count, UInt64>,
        hashMaxBytes: Int,
        requireExactPaths: Bool
    ) -> [MemberBlockItemSyntax]? {
        let perfectHashGenerator = PerfectHashGenerator(
            routes: routePathSIMDs,
            maxBytes: hashMaxBytes,
            positions: perfectHashPositions
        )
        let minimal:Bool
        let candidate:HashCandidate
        let hashTable:[UInt8]
        let verificationKeys:[UInt64]
        let efficiency:Double
        if let result = perfectHashGenerator.findMinimalPerfectHash(seeds: seeds) {
            minimal = true
            candidate = result.candidate
            hashTable = result.result.hashTable
            verificationKeys = result.result.verificationKeys
            efficiency = 100
        } else if let result = perfectHashGenerator.generatePerfectHash(seeds: seeds) {
            minimal = false
            candidate = result.candidate
            hashTable = result.hashTable
            verificationKeys = result.verificationKeys
            efficiency = result.efficiency
        } else {
            return nil
        }

        let routeEntryInitializeLogic:(Int, UInt64) -> String
        if perfectHashSettings.requireExactPaths {
            if minimal {
                routeEntryInitializeLogic = { index, _ in
                    return ", \(routePathSIMDs[index].simd)"
                }
            } else {
                routeEntryInitializeLogic = { index, key in
                    return ", \(routePathSIMDs[index].simd), \(key)"
                }
            }
        } else {
            if minimal {
                routeEntryInitializeLogic = { _, _ in "" }
            } else {
                routeEntryInitializeLogic = { index, key in
                    return ", \(key)"
                }
            }
        }
        let staticRoutesTableString = hashTable.map({
            guard $0 != 255 else { return "nil" }
            let key = verificationKeys[Int($0)]
            return ".init(.`\(routePaths[Int($0)])`\(routeEntryInitializeLogic(Int($0), key)))"
        }).joined(separator: ",\n")
        let hashTableDecl = VariableDeclSyntax.init(
            modifiers: [.init(name: .keyword(.static))],
            .let,
            name: "hashTable",
            type: .init(type: TypeSyntax.init(stringLiteral: "InlineArray<\(hashTable.count), RouteEntry?>")),
            initializer: .init(leadingTrivia: " ", value: ExprSyntax.init(stringLiteral: "[\n\(staticRoutesTableString)\n]"))
        )

        let positions = perfectHashGenerator.positions
        var extractKeyLiteral = ""
        for offset in 0..<hashMaxBytes {
            var s = "UInt64(simd[\(positions[offset])])"
            if offset != 0 {
                s = "\n    | (\(s) << \(offset * hashMaxBytes))"
            }
            extractKeyLiteral += s
        }

        let extractKeyDecl = FunctionDeclSyntax(
            leadingTrivia: "\(inlinableAnnotation)\n\(inlineAlwaysAnnotation)\n",
            modifiers: [visibilityModifier],
            name: "extractKey",
            signature: .init(
                parameterClause: .init(parameters: [
                    .init(leadingTrivia: "\n", firstName: "_", secondName: "simd", type: TypeSyntax("SIMD64<UInt8>"), trailingTrivia: "\n")
                ]),
                returnClause: .init(type: TypeSyntax("UInt64")),
            ),
            body: .init(statements: [
                .init(stringLiteral: "return \(extractKeyLiteral)")
            ])
        )

        let perfectHashReturns:(annotation: String, literal: String)        
        var hashString = "Int(((key &* \(candidate.seed)) >> \(candidate.shift)) & \((candidate.mask)))"
        if minimal {
            hashString += " % \(routePaths.count)"
            perfectHashReturns = ("Int", "\(hashString)")
        } else {
            if candidate.finalHashSubtraction > 0 {
                hashString += " - \(candidate.finalHashSubtraction)"
            }
            perfectHashReturns = ("(key: UInt64, hash: Int)", "(key, \(hashString))")
        }

        let perfectHashDecl = try! FunctionDeclSyntax.init("""
        \(raw: inlinableAnnotation)
        \(raw: inlineAlwaysAnnotation)
        \(raw: visibility)func perfectHash(
            _ simd: SIMD64<UInt8>
        ) -> \(raw: perfectHashReturns.annotation) {
            let key = extractKey(simd)
            return \(raw: perfectHashReturns.literal)
        }
        """)

        let routeEntryDecl = perfectHashRouteEntryDecl(
            minimal: minimal,
            hashMaxBytes: hashMaxBytes,
            requireExactPaths: requireExactPaths,
            efficiency: efficiency
        )
        let matchRouteDecl = matchRoutePerfectHashDecl(
            minimal: minimal,
            hashTable: hashTable,
            hashMaxBytes: hashMaxBytes,
            requireExactPaths: requireExactPaths
        )
        return [
            .init(decl: routeEntryDecl),
            .init(decl: hashTableDecl),
            .init(decl: extractKeyDecl),
            .init(decl: perfectHashDecl),
            .init(decl: matchRouteDecl)
        ]
    }
    private func perfectHashRouteEntryDecl(
        minimal: Bool,
        hashMaxBytes: Int,
        requireExactPaths: Bool,
        efficiency: Double
    ) -> StructDeclSyntax {
        let simd:(variable: String, initializer: String, assignment: String)
        if requireExactPaths {
            simd = (
                "let simd:SIMD64<UInt8>\n",
                "_ simd: SIMD64<UInt8>,\n",
                "self.simd = simd\n"
            )
        } else {
            simd = ("", "", "")
        }
        let values:(comment: String, keyVariable: String, keyAnnotation: String, keyAssignment: String)
        if minimal {
            values = ("minimal ", "", "", "")
        } else {
            values = (
                "",
                "let key:UInt64\n",
                "_ key: UInt64",
                "self.key = key"
            )
        }
        return try! StructDeclSyntax.init("""
        struct RouteEntry: Sendable { // found \(raw: values.comment)perfect hash with \(raw: hashMaxBytes) character\(raw: hashMaxBytes == 1 ? "" : "s") (\(raw: efficiency)% efficiency)
            \(raw: values.keyVariable)\(raw: simd.variable)let route:Route
            init(
                _ route: Route,
                \(raw: simd.initializer)\(raw: values.keyAnnotation)
            ) {
                self.route = route
                \(raw: simd.assignment)\(raw: values.keyAssignment)
            }
        }
        """)
    }
    private func matchRoutePerfectHashDecl(
        minimal: Bool,
        hashTable: [UInt8],
        hashMaxBytes: Int,
        requireExactPaths: Bool
    ) -> FunctionDeclSyntax {
        let returnLogic:String
        if requireExactPaths {
            returnLogic = "entry.simd == simd ? entry.route : nil"
        } else {
            returnLogic = "entry.route"
        }
        let values:(variables: String, hashCollectionCheck: String)
        if minimal {
            values = ("hashIndex", "")
        } else {
            values = ("(key, hashIndex)", ", entry.key == key")
        }
        return .init(
            leadingTrivia: "\(inlinableAnnotation)\n\(inlineAlwaysAnnotation)\n",
            name: "matchRoute",
            signature: .init(
                parameterClause: .init(parameters: [
                    .init(leadingTrivia: "\n", firstName: "_", secondName: "simd", type: TypeSyntax("SIMD64<UInt8>"), trailingTrivia: "\n")
                ]),
                returnClause: .init(type: TypeSyntax("Route?"))
            ),
            body: .init(statements: .init(stringLiteral: """
                let \(values.variables) = perfectHash(simd)
                guard hashIndex < \(hashTable.count), let entry = Self.hashTable[hashIndex]\(values.hashCollectionCheck) else { return nil }
                return \(returnLogic)
                """)
            ),
        )
    }
}

// MARK: Match route fallback decl
extension RouterStorage {
    private func matchRouteFallbackDecl(
        routePaths: [String]
    ) -> FunctionDeclSyntax {
        return .init(
            leadingTrivia: "\(inlinableAnnotation)\n\(inlineAlwaysAnnotation)\n",
            modifiers: [visibilityModifier],
            name: "matchRoute",
            signature: .init(
                parameterClause: .init(parameters: [
                    .init(leadingTrivia: "\n", firstName: "_", secondName: "simd", type: TypeSyntax("SIMD64<UInt8>"), trailingTrivia: "\n")
                ]),
                returnClause: .init(type: TypeSyntax("Route?"))
            ),
            body: .init(statements: .init(stringLiteral: """
                switch simd {
                \((0..<routePaths.count).map({ "case Self.simd\($0): .`\(routePaths[$0])`" }).joined(separator: "\n"))
                default: nil
                }
                """)
            ),
        )
    }
}