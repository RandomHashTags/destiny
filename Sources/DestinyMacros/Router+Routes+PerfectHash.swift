

import DestinyBlueprint
import DestinyDefaults
import SwiftDiagnostics
import SwiftSyntax
import SwiftSyntaxMacros

extension RouterStorage {
    mutating func perfectHashStorage(
        mutable: Bool,
        context: some MacroExpansionContext,
        caseSensitive: Bool
    ) -> String {
        let namePrefix:String
        let staticRoutes:[(StaticRoute, FunctionCallExprSyntax)]
        let dynamicRoutes:[(DynamicRoute, FunctionCallExprSyntax)]
        let random:Int
        if caseSensitive {
            namePrefix = "CaseSensitive"
            random = autoGeneratedCaseSensitiveRespondersIndex
            staticRoutes = staticCaseSensitiveRoutes
            dynamicRoutes = dynamicCaseSensitiveRoutes
        } else {
            namePrefix = "CaseInsensitive"
            random = autoGeneratedCaseInsensitiveRespondersIndex
            staticRoutes = staticCaseInsensitiveRoutes
            dynamicRoutes = dynamicCaseInsensitiveRoutes
        }
        var enumDecl = StructDeclSyntax(
            leadingTrivia: "// MARK: \(namePrefix)ResponderStorage\(random)\n\(visibility)",
            name: "\(raw: namePrefix)ResponderStorage\(raw: random)",
            inheritanceClause: .init(
                inheritedTypes: .init(arrayLiteral:
                    .init(type: TypeSyntax.init(stringLiteral: "ResponderStorageProtocol"), trailingComma: ","),
                    .init(type: TypeSyntax.init(stringLiteral: "Copyable"))
                )
            ),
            memberBlock: .init(members: .init())
        )

        let reservedCapacity = staticRoutes.count + dynamicRoutes.count
        var routePaths = [String]()
        var routeResponders = [String]()
        var literalRouteResponders = [String]()
        routePaths.reserveCapacity(reservedCapacity)
        routeResponders.reserveCapacity(reservedCapacity)
        literalRouteResponders.reserveCapacity(reservedCapacity)

        appendStaticRoutes(
            context: context,
            middleware: staticMiddleware,
            isCaseSensitive: caseSensitive,
            routes: staticRoutes,
            literalRoutePaths: &routePaths,
            routeResponders: &routeResponders,
            literalRouteResponders: &literalRouteResponders
        )
        appendDynamicRoutes(
            context: context,
            isCaseSensitive: caseSensitive,
            routes: dynamicRoutes,
            literalRoutePaths: &routePaths,
            routeResponders: &routeResponders,
            literalRouteResponders: &literalRouteResponders
        )

        staticConstants(
            context: context,
            isCaseSensitive: caseSensitive,
            routePaths: routePaths,
            enumDecl: &enumDecl,
            literalRouteResponders: literalRouteResponders
        )

        generatedDecls.append(enumDecl)    
        if caseSensitive {
            autoGeneratedCaseSensitiveRespondersIndex += 1
        } else {
            autoGeneratedCaseInsensitiveRespondersIndex += 1
        }
        return "\(enumDecl.name.text)()"
    }
}

// MARK: Static routes
extension RouterStorage {
    mutating func appendStaticRoutes(
        context: some MacroExpansionContext,
        middleware: [CompiledStaticMiddleware],
        isCaseSensitive: Bool,
        routes: [(StaticRoute, FunctionCallExprSyntax)],
        literalRoutePaths: inout [String],
        routeResponders: inout [String],
        literalRouteResponders: inout [String]
    ) {
        let routeStartLine:(StaticRoute) -> String = isCaseSensitive ? { $0.startLine } : { $0.startLine.lowercased() }
        let getResponderValue:(RouterStorage.Route) -> String = {
            let responder = $0.responder
            return "// \($0.startLine)\nCompiledStaticResponderStorageRoute(\npath: \($0.buffer),\nresponder: \(responder)\n)"
        }
        for (route, function) in routes {
            do throws(HTTPMessageError) {
                var startLine = routeStartLine(route)
                if registeredPaths.contains(startLine) {
                    Router.routePathAlreadyRegistered(context: context, node: function, startLine)
                } else {
                    registeredPaths.insert(startLine)
                    let buffer = SIMD64<UInt8>(&startLine)
                    let httpResponse = route.response(context: context, function: function, middleware: middleware) as! HTTPResponseMessage // TODO: fix
                    if true /*route.supportedCompressionAlgorithms.isEmpty*/ {
                        if let responder = try responseBodyResponderDebugDescription(body: route.body, response: httpResponse) {
                            literalRoutePaths.append("\(startLine)")
                            literalRouteResponders.append(responder)
                            routeResponders.append(getResponderValue(.init(startLine: startLine, buffer: buffer, responder: responder)))
                            if isCaseSensitive {
                                if let index = staticCaseSensitiveRoutes.firstIndex(where: { $0.0.path == route.path && $0.1 == function }) {
                                    staticCaseSensitiveRoutes.remove(at: index)
                                }
                            } else {
                                if let index = staticCaseInsensitiveRoutes.firstIndex(where: { $0.0.path == route.path && $0.1 == function }) {
                                    staticCaseInsensitiveRoutes.remove(at: index)
                                }
                            }
                        } else {
                            context.diagnose(Diagnostic(node: function, message: DiagnosticMsg(id: "failedToGetResponderDebugDescriptionForResponseBody", message: "Failed to get responder debug description for response body; body=\(String(describing: route.body));function=\(function.debugDescription)", severity: .warning)))
                        }
                    } else if let httpResponse = httpResponse as? HTTPResponseMessage {
                        Router.conditionalRoute(
                            context: context,
                            conditionalResponders: &conditionalResponders,
                            route: route,
                            function: function,
                            string: startLine,
                            buffer: buffer,
                            httpResponse: httpResponse
                        )
                    } else {
                        context.diagnose(Diagnostic(node: function, message: DiagnosticMsg(id: "unexpectedHTTPResponseMessage", message: "Router.Storage;staticRoutesSyntax;conditionalRoute;httpResponse variable is not a HTTPResponseMessage")))
                    }
                }
            } catch {
                context.diagnose(Diagnostic(node: function, message: DiagnosticMsg(id: "staticRouteError", message: "\(error)")))
            }
        }
    }
}

// MARK: Dynamic routes
extension RouterStorage {
    mutating func appendDynamicRoutes(
        context: some MacroExpansionContext,
        isCaseSensitive: Bool,
        routes: [(DynamicRoute, FunctionCallExprSyntax)],
        literalRoutePaths: inout [String],
        routeResponders: inout [String],
        literalRouteResponders: inout [String]
    ) {
        let routeStartLine:(DynamicRoute) -> String = isCaseSensitive ? { $0.startLine() } : { $0.startLine().lowercased() }
        for (route, function) in routes {
            guard route.path.firstIndex(where: { !$0.isLiteral }) == nil else { continue }
            let startLine = routeStartLine(route)
            if registeredPaths.contains(startLine) {
                Router.routePathAlreadyRegistered(context: context, node: function, startLine)
            } else {
                registeredPaths.insert(startLine)
                let (responder, _) = getResponderValue(
                    route: .init(startLine: startLine, buffer: .init(startLine), responder: route.responderDebugDescription)
                )
                literalRoutePaths.append(route.startLine())
                literalRouteResponders.append(responder)

                if isCaseSensitive {
                    if let index = dynamicCaseSensitiveRoutes.firstIndex(where: { $0.0.path == route.path && $0.1 == function }) {
                        dynamicCaseSensitiveRoutes.remove(at: index)
                    }
                } else {
                    if let index = dynamicCaseInsensitiveRoutes.firstIndex(where: { $0.0.path == route.path && $0.1 == function }) {
                        dynamicCaseInsensitiveRoutes.remove(at: index)
                    }
                }
            }
        }
    }
}

// MARK: Static constants
extension RouterStorage {
    private func staticConstants(
        context: some MacroExpansionContext,
        isCaseSensitive: Bool,
        routePaths: [String],
        enumDecl: inout StructDeclSyntax,
        literalRouteResponders: [String]
    ) {
        var routePathCaseNames = [String]()
        var routePathSIMDs = [SIMD64<UInt8>]()
        var staticResponders = [VariableDeclSyntax]()
        var staticSIMDs = [VariableDeclSyntax]()

        routePathCaseNames.reserveCapacity(routePaths.count)
        routePathSIMDs.reserveCapacity(routePaths.count)
        staticResponders.reserveCapacity(routePaths.count)
        staticSIMDs.reserveCapacity(routePaths.count)
        for (index, routePath) in routePaths.enumerated() {
            routePathCaseNames.append("`\(routePath)`")

            let utf8 = routePath.utf8
            var simd = SIMD64<UInt8>.zero
            let utf8Count = utf8.count
            if utf8Count > 0 {
                for i in 0..<min(simd.scalarCount, utf8Count) {
                    simd[i] = utf8[utf8.index(utf8.startIndex, offsetBy: i)]
                }
            }
            routePathSIMDs.append(simd)

            let staticResponder = try! VariableDeclSyntax.init("""
            /// Request: `\(raw: routePath)`
            \(raw: visibility)static let responder\(raw: index) = \(raw: literalRouteResponders[index])
            """)
            staticResponders.append(staticResponder)

            let staticSIMD = try! VariableDeclSyntax.init("""
            \(raw: visibility)static let simd\(raw: index) = \(raw: simd)
            """)
            staticSIMDs.append(staticSIMD)
        }

        let routeResponderDecl = try! FunctionDeclSyntax.init("""
        @inlinable
        \(raw: visibility)func respond(
            router: some HTTPRouterProtocol,
            socket: some FileDescriptor,
            request: inout some HTTPRequestProtocol & ~Copyable,
            completionHandler: @Sendable @escaping () -> Void
        ) throws(ResponderError) -> Bool {
            switch self {
            \(raw: routePathCaseNames.enumerated().map({ "case .\($0.element):\ntry Self.responder\($0.offset).respond(router: router, socket: socket, request: &request, completionHandler: completionHandler)" }).joined(separator: "\n"))
            }
            return true
        }
        """)
        var routeConstantsDecl = try! EnumDeclSyntax.init("""
        \(raw: visibility)enum Route: UInt16 { // \(raw: routePaths.count)
        }
        """)
        for caseName in routePathCaseNames {
            routeConstantsDecl.memberBlock.members.append(.init(decl: try! EnumCaseDeclSyntax.init("case \(raw: caseName)")))
        }
        routeConstantsDecl.memberBlock.members.append(.init(decl: routeResponderDecl))
        routeConstantsDecl.memberBlock.members.append(contentsOf: staticResponders.map({ .init(decl: $0) }))
        enumDecl.memberBlock.members.append(.init(decl: routeConstantsDecl))

        var foundPerfectHash = false
        if perfectHashSettings.enabled {
            //let relaxedRoutePaths = routePaths.filter({ perfectHashSettings.relaxedRoutePaths.contains($0) }) // TODO: support
            let perfectHashableItems:[PerfectHashableItem<SIMD64<UInt8>>] = routePaths.enumerated().map({
                return .init($1, routePathSIMDs[$0])
            })
            let perfectHashPositions = PerfectHashGenerator.findPerfectHashPositions(routes: perfectHashableItems, maxBytes: perfectHashSettings.maxBytes.max()!)
            let hashSeeds:InlineArray<_, UInt64> = [
                0x9E3779B97F4A7C15,
                0xC6A4A7935D83A9C3,
                0x5555555555555555,
                0x1234567812345678,
                0x1F1F1F1F1F1F1F1F,
                0xFFFFFFFFFFFFFFFF,
                0x3141592653589793,
                0xDEADBEEFDEADBEEF,
                0xBADC0FFEBADC0FFE,
                0xCAFEBABECAFEBABE,
                0x0A0A0A0A0A0A0A0A,
                0x8000000080000000,
                0x1BADB0021BADB002,
                0xF00DF00DF00DF00D,
                0xBEAFBEAFBEAFBEAF,
                0x5A5A5A5A5A5A5A5A,
                0x8BADF00D8BADF00D,
                0xDEADD00DDEADD00D,
                0x1234ABCD1234ABCD,
                0x7F7F7F7F7F7F7F7F,
                0x2B2B2B2B2B2B2B2B,
                0x1E1E1E1E1E1E1E1E,
                0xA5A5A5A5A5A5A5A5,
                0x6C6C6C6C6C6C6C6C,
                0xF1F1F1F1F1F1F1F1,
                0x3C3C3C3C3C3C3C3C,
                0x8C8C8C8C8C8C8C8C,
                0xFEEDFACEFEEDFACE,
                0x1234123412341234,
                0x4567456745674567,
                0x9988776655443322,
                0xCDCDCDCDCDCDCDCD,
                0x1111111111111111,
                0x9999999999999999,
                0xDEEDDEEDDEEDDEED,
                0xFEEDBEEFFEEDBEEF,
                0xABCDEABCABCDEABC,
                0x5B5B5B5B5B5B5B5B,
                0x8001C8001C8001C8,
                0xD9D9D9D9D9D9D9D9,
                0x1112222333445555,
                0x9C9C9C9C9C9C9C9C,
                0xA8A8A8A8A8A8A8A8,
                0xE1E1E1E1E1E1E1E1,
                0x5D5D5D5D5D5D5D5D,
                0x4F4F4F4F4F4F4F4F,
                0xBABABABABABABABA,
                0x6E6E6E6E6E6E6E6E,
                0x7D7D7D7D7D7D7D7D,
                0x9F9F9F9F9F9F9F9F
            ]
            for hashBytes in perfectHashSettings.maxBytes {
                if let perfectHashDecls = matchRoutePerfectHash(
                    routePaths: routePaths,
                    routePathSIMDs: perfectHashableItems,
                    perfectHashPositions: perfectHashPositions,
                    seeds: hashSeeds,
                    hashMaxBytes: hashBytes,
                    requireExactPaths: perfectHashSettings.requireExactPaths
                ) {
                    enumDecl.memberBlock.members.append(contentsOf: perfectHashDecls.map({ .init(decl: $0) }))
                    foundPerfectHash = true
                    break
                }
            }
        }
        if !foundPerfectHash {
            enumDecl.memberBlock.members.append(contentsOf: staticSIMDs.map({ .init(decl: $0) }))
            enumDecl.memberBlock.members.append(.init(decl: matchRouteFallback(routePaths: routePaths)))
        }

        let responderDecl = try! FunctionDeclSyntax.init("""
        @inlinable
        \(raw: visibility)func respond(
            router: some HTTPRouterProtocol,
            socket: some FileDescriptor,
            request: inout some HTTPRequestProtocol & ~Copyable,
            completionHandler: @Sendable @escaping () -> Void
        ) throws(ResponderError) -> Bool {
            let startLine:SIMD64<UInt8>
            do throws(SocketError) {
                startLine = try request.startLine\(raw: isCaseSensitive ? "" : "Lowercased")()
            } catch {
                throw .socketError(error)
            }
            guard let route = matchRoute(startLine) else { return false }
            return try route.respond(router: router, socket: socket, request: &request, completionHandler: completionHandler)
        }
        """)
        enumDecl.memberBlock.members.append(.init(decl: responderDecl))
    }
}

// MARK: Match route
extension RouterStorage {
    private func matchRoutePerfectHash<let count: Int>(
        routePaths: [String],
        routePathSIMDs: [PerfectHashableItem<SIMD64<UInt8>>],
        perfectHashPositions: InlineArray<64, Int>,
        seeds: InlineArray<count, UInt64>,
        hashMaxBytes: Int,
        requireExactPaths: Bool
    ) -> [any DeclSyntaxProtocol]? {
        let perfectHashGenerator = PerfectHashGenerator(
            routes: routePathSIMDs,
            maxBytes: hashMaxBytes,
            positions: perfectHashPositions
        )
        let candidate:HashCandidate
        let hashTable:[UInt8]
        let verificationKeys:[UInt64]
        let efficiency:Double
        if let result = perfectHashGenerator.findMinimalPerfectHash(seeds: seeds) {
            candidate = result.candidate
            hashTable = result.result.hashTable
            verificationKeys = result.result.verificationKeys
            efficiency = 100
        } else if let result = perfectHashGenerator.generatePerfectHash(seeds: seeds) {
            candidate = result.candidate
            hashTable = result.hashTable
            verificationKeys = result.verificationKeys
            efficiency = result.efficiency
        } else {
            return nil
        }

        let routeEntryInitializeLogic:(Int, UInt64) -> String
        if perfectHashSettings.requireExactPaths {
            routeEntryInitializeLogic = { index, key in
                return "\(routePathSIMDs[index].simd), \(key)"
            }
        } else {
            routeEntryInitializeLogic = { index, key in
                return "\(key)"
            }
        }
        let staticRoutesTableString = hashTable.map({
            guard $0 != 255 else { return "nil" }
            let key = verificationKeys[Int($0)]
            return ".init(.`\(routePaths[Int($0)])`, \(routeEntryInitializeLogic(Int($0), key)))"
        }).joined(separator: ",\n")
        let hashTableDecl = VariableDeclSyntax.init(
            modifiers: .init(arrayLiteral: DeclModifierSyntax.init(name: "static")),
            .let,
            name: "hashTable",
            type: .init(type: TypeSyntax.init(stringLiteral: "InlineArray<\(hashTable.count), RouteEntry?>")),
            initializer: .init(leadingTrivia: " ", value: ExprSyntax.init(stringLiteral: "[\n\(staticRoutesTableString)\n]"))
        )

        let positions = perfectHashGenerator.positions
        var extractKeyLiteral = ""
        for offset in 0..<hashMaxBytes {
            var s = "UInt64(simd[\(positions[offset])])"
            if offset != 0 {
                s = "\n    | (\(s) << \(offset * hashMaxBytes))"
            }
            extractKeyLiteral += s
        }

        let extractKeyDecl = try! FunctionDeclSyntax.init("""
        @inlinable @inline(__always)
        \(raw: visibility)func extractKey(_ simd: SIMD64<UInt8>) -> UInt64 {
            return \(raw: extractKeyLiteral)
        }
        """)

        let perfectHashDecl = try! FunctionDeclSyntax.init("""
        @inlinable @inline(__always)
        \(raw: visibility)func perfectHash(
            _ simd: SIMD64<UInt8>
        ) -> (key: UInt64, hash: Int) {
            let key = extractKey(simd)
            return (key, Int(((key &* \(raw: candidate.seed)) >> \(raw: candidate.shift)) & \(raw: candidate.mask)) - \(raw: candidate.finalHashSubtraction))
        }
        """)

        let routeEntryDecl = matchRoutePerfectHashEntry(hashMaxBytes: hashMaxBytes, requireExactPaths: requireExactPaths, efficiency: efficiency)
        let matchRouteDecl = matchRoutePerfectHashDecl(hashTable: hashTable, hashMaxBytes: hashMaxBytes, requireExactPaths: requireExactPaths)
        return [
            routeEntryDecl,
            hashTableDecl,
            extractKeyDecl,
            perfectHashDecl,
            matchRouteDecl
        ]
    }
    private func matchRoutePerfectHashEntry(
        hashMaxBytes: Int,
        requireExactPaths: Bool,
        efficiency: Double
    ) -> StructDeclSyntax {
        let simd:(variable: String, initializer: String, assignment: String)
        if requireExactPaths {
            simd = (
                "let simd:SIMD64<UInt8>\n",
                "_ simd: SIMD64<UInt8>,\n",
                "self.simd = simd\n"
            )
        } else {
            simd = ("", "", "")
        }
        return try! StructDeclSyntax.init("""
        struct RouteEntry: Sendable { // found perfect hash with \(raw: hashMaxBytes) characters (\(raw: efficiency)% efficiency)
            let key:UInt64
            \(raw: simd.variable)let route:Route
            init(
                _ route: Route,
                \(raw: simd.initializer)_ key: UInt64
            ) {
                self.route = route
                \(raw: simd.assignment)self.key = key
            }
        }
        """)
    }
    private func matchRoutePerfectHashDecl(
        hashTable: [UInt8],
        hashMaxBytes: Int,
        requireExactPaths: Bool
    ) -> FunctionDeclSyntax {
        let returnLogic:String
        if requireExactPaths {
            returnLogic = "entry.simd == simd ? entry.route : nil"
        } else {
            returnLogic = "entry.route"
        }
        return try! FunctionDeclSyntax.init("""
        @inlinable @inline(__always)
        \(raw: visibility)func matchRoute(_ simd: SIMD64<UInt8>) -> Route? {
            let (key, hashIndex) = perfectHash(simd)
            guard hashIndex < Self.hashTable.count, let entry = Self.hashTable[hashIndex] else { return nil }
            if entry.key != key { // hash collision
                return nil
            }
            return \(raw: returnLogic)
        }
        """)
    }

    private func matchRouteFallback(
        routePaths: [String]
    ) -> FunctionDeclSyntax {
        return try! FunctionDeclSyntax.init("""
        @inlinable
        \(raw: visibility)func matchRoute(_ simd: SIMD64<UInt8>) -> Route? {
            switch simd {
            \(raw: (0..<routePaths.count).map({ "case Self.simd\($0): .`\(routePaths[$0])`" }).joined(separator: "\n"))
            default: nil
            }
        }
        """)
    }
}