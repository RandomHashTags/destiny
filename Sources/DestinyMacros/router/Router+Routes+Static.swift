
import DestinyBlueprint
import DestinyDefaults
import SwiftDiagnostics
import SwiftSyntax
import SwiftSyntaxMacros

// MARK: Static routes string
extension RouterStorage {
    mutating func staticRoutesResponder(
        context: some MacroExpansionContext,
        isCaseSensitive: Bool
    ) -> CompiledRouterStorage.Responder? {
        let routes = isCaseSensitive ? staticRouteStorage.caseSensitiveRoutes : staticRouteStorage.caseInsensitiveRoutes
        if routes.isEmpty {
            #if StaticRedirectionRoute
            if staticRedirects.isEmpty {
                return nil
            }
            #else
            return nil
            #endif
        }

        let tempData = SharedStaticRouteResponderData(storage: self, isCaseSensitive: isCaseSensitive)
        let copyable:String?
        let noncopyable:String?
        if let decl = responderStorageDeclName(
            context: context,
            isCaseSensitive: isCaseSensitive,
            isCopyable: true,
            data: tempData,
            routes: routes
        ) {
            copyable = "\(decl)()"
        } else {
            copyable = nil
        }
        if let decl = responderStorageDeclName(
            context: context,
            isCaseSensitive: isCaseSensitive,
            isCopyable: false,
            data: tempData,
            routes: routes
        ) {
            noncopyable = "\(decl)()"
        } else {
            noncopyable = nil
        }
        return .get(copyable, noncopyable)
    }
}

// MARK: TempData
extension RouterStorage {
    struct SharedStaticRouteResponderData: Sendable, ~Copyable {
        let name:String
        let routeStartLine:@Sendable (StaticRoute) -> String

        #if StaticRedirectionRoute
        let getRedirectRouteStartLine:@Sendable (StaticRedirectionRoute) -> String
        #endif

        init(
            storage: RouterStorage,
            isCaseSensitive: Bool
        ) {
            let random:Int
            let namePart:String
            if isCaseSensitive {
                random = storage.autoGeneratedCaseSensitiveRespondersIndex
                namePart = "S"
                routeStartLine = { $0.startLine }

                #if StaticRedirectionRoute
                getRedirectRouteStartLine = { $0.fromStartLine() }
                #endif
            } else {
                random = storage.autoGeneratedCaseInsensitiveRespondersIndex
                namePart = "Ins"
                routeStartLine = { $0.startLine.lowercased() }

                #if StaticRedirectionRoute
                getRedirectRouteStartLine = { $0.fromStartLine().lowercased() }
                #endif
            }
            name = "Case\(namePart)ensitiveResponderStorage\(random)"
        }
    }
}

// MARK: Responder storage decl
extension RouterStorage {
    private mutating func responderStorageDeclName(
        context: some MacroExpansionContext,
        isCaseSensitive: Bool,
        isCopyable: Bool,
        data: borrowing SharedStaticRouteResponderData,
        routes: [(StaticRoute, FunctionCallExprSyntax)]
    ) -> String? {
        if isCopyable {
            #if !Copyable
            return nil
            #endif
        } else {
            #if !NonCopyable
            return nil
            #endif
        }
        var routePaths = [String]()
        var literalRouteResponders = [String]()
        routePaths.reserveCapacity(routes.count)
        literalRouteResponders.reserveCapacity(routes.count)
        appendStaticRoutes(
            context: context,
            isCaseSensitive: isCaseSensitive,
            isCopyable: isCopyable,
            data: data,
            routes: routes,
            routePaths: &routePaths,
            routeResponders: &literalRouteResponders
        )
        guard !routePaths.isEmpty else { return nil }

        let enumDecl = StructDeclSyntax(
            leadingTrivia: "// MARK: \(data.name)\n",
            modifiers: [visibilityModifier],
            name: "\(raw: data.name)",
            inheritanceClause: .init(
                inheritedTypes: responderStorageProtocolConformances(isCopyable: isCopyable, protocolConformance: hasProtocolConformances)
            ),
            memberBlock: .init(members: .init())
        )

        generatedDecls.append(enumDecl)    
        if isCaseSensitive {
            autoGeneratedCaseSensitiveRespondersIndex += 1
        } else {
            autoGeneratedCaseInsensitiveRespondersIndex += 1
        }
        return data.name
    }
}

// MARK: Append routes
extension RouterStorage {
    mutating func appendStaticRoutes(
        context: some MacroExpansionContext,
        isCaseSensitive: Bool,
        isCopyable: Bool,
        routes: [(StaticRoute, FunctionCallExprSyntax)],
        routePaths: inout [String],
        routeResponders: inout [String]
    ) {
        appendStaticRoutes(
            context: context,
            isCaseSensitive: isCaseSensitive,
            isCopyable: isCopyable,
            data: .init(storage: self, isCaseSensitive: isCaseSensitive),
            routes: routes,
            routePaths: &routePaths,
            routeResponders: &routeResponders
        )
    }
    mutating func appendStaticRoutes(
        context: some MacroExpansionContext,
        isCaseSensitive: Bool,
        isCopyable: Bool,
        data: borrowing SharedStaticRouteResponderData,
        routes: [(StaticRoute, FunctionCallExprSyntax)],
        routePaths: inout [String],
        routeResponders: inout [String]
    ) {
        let getResponderValue:(RouterStorage.Route) -> String = {
            "// \($0.startLine)\nCompiledStaticResponderStorageRoute(\npath: \($0.buffer),\nresponder: \($0.responder)\n)"
        }
        if !isCopyable { // always make redirects noncopyable for optimal performance
            #if StaticRedirectionRoute
            appendStaticRedirects(
                context: context,
                isCaseSensitive: isCaseSensitive,
                isCopyable: isCopyable,
                routePaths: &routePaths,
                routeResponders: &routeResponders,
                data: data,
                getResponderValue: getResponderValue
            )
            #endif
        }
        for (route, function) in routes {
            let startLine = data.routeStartLine(route)
            #if StaticMiddleware
            let httpResponse = route.response(context: context, function: function, middleware: staticMiddleware)
            #else
            let httpResponse = route.response(context: context, function: function)
            #endif
            if true /*route.supportedCompressionAlgorithms.isEmpty*/ {
                if let intermediateBody = route.body {
                    guard isCopyable != intermediateBody.isNoncopyable else {
                        continue
                    }
                }
                guard !registeredPaths.contains(startLine) else {
                    Router.routePathAlreadyRegistered(context: context, node: function, startLine)
                    continue
                }
                guard let responder = route.body?.responderDebugDescription(context: context, isCopyable: isCopyable, response: httpResponse) else {
                    context.diagnose(.init(node: function, message: DiagnosticMsg(id: "failedToGetResponderDebugDescriptionForResponseBody", message: "Failed to get responder debug description for response body; body=\(String(describing: route.body));function=\(function.debugDescription)", severity: .warning)))
                    continue
                }
                registeredPaths.insert(startLine)
                routePaths.append(startLine)
                routeResponders.append(responder)
                staticRouteStorage.remove(isCaseSensitive: isCaseSensitive, path: route.path, function: function)
            } else {
                guard !registeredPaths.contains(startLine) else {
                    Router.routePathAlreadyRegistered(context: context, node: function, startLine)
                    continue
                }
                registeredPaths.insert(startLine)
                // TODO: fix
                /*Router.conditionalRoute(
                    context: context,
                    conditionalResponders: &conditionalResponders,
                    route: route,
                    function: function,
                    string: startLine,
                    buffer: buffer,
                    httpResponse: httpResponse
                )*/
            }
        }
    }
}

#if StaticRedirectionRoute

// MARK: Append redirects
extension RouterStorage {
    private mutating func appendStaticRedirects(
        context: some MacroExpansionContext,
        isCaseSensitive: Bool,
        isCopyable: Bool,
        routePaths: inout [String],
        routeResponders: inout [String],
        data: borrowing SharedStaticRouteResponderData,
        getResponderValue: (RouterStorage.Route) -> String
    ) {
        var removedRedirects = [Int]()
        removedRedirects.reserveCapacity(staticRedirects.count)
        for (index, redirect) in staticRedirects.enumerated() {
            let (route, function) = redirect
            guard route.isCaseSensitive == isCaseSensitive else {
                continue
            }
            let string = data.getRedirectRouteStartLine(route)
            guard !registeredPaths.contains(string) else {
                Router.routePathAlreadyRegistered(context: context, node: function, string)
                continue
            }
            registeredPaths.insert(string)
            routePaths.append(string)
            removedRedirects.append(index)

            let stringLiteral = StringLiteralExprSyntax(content: "")
            let responder = IntermediateResponseBody(
                type: .staticStringWithDateHeader,
                .init(stringLiteral)
            ).responderDebugDescription(context: context, isCopyable: isCopyable, response: route.response())
            routeResponders.append(responder)
        }
        for i in removedRedirects.reversed() {
            staticRedirects.remove(at: i)
        }
    }
}

#endif