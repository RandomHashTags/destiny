
import Destiny
import SwiftSyntax
import SwiftSyntaxMacros

public struct RouterStorage {
    #if RouterSettings
    let settings:RouterSettings
    #endif

    let perfectHashSettings:PerfectHashSettings
    var generatedDecls = MemberBlockItemListSyntax()

    var autoGeneratedCaseSensitiveRespondersIndex = 0
    var autoGeneratedCaseInsensitiveRespondersIndex = 0
    var upgradeExistentialDynamicMiddleware = [FunctionCallExprSyntax]()

    var dynamicMiddleware = [FunctionCallExprSyntax]()

    var dynamicRouteStorage = DynamicRouteStorage()
    var staticRouteStorage = StaticRouteStorage()

    #if StaticMiddleware
    var staticMiddleware = [StaticMiddleware]()
    var staticMiddlewareFunctions = [FunctionCallExprSyntax]()
    #endif

    #if StaticRedirectionRoute
    var staticRedirects:[(StaticRedirectionRoute, FunctionCallExprSyntax)] = []
    #endif

    var routeGroups = [any DeclSyntaxProtocol]()

    var registeredPaths:Set<String> = []

    lazy var autoGeneratedOpaqueDynamicMiddleware: String? = {
        guard !upgradeExistentialDynamicMiddleware.isEmpty else { return nil }
        for (i, function) in upgradeExistentialDynamicMiddleware.enumerated() {
            guard let statements = function.arguments.first?.expression.as(ClosureExprSyntax.self)?.statements else {
                continue
            }
            var functionString = ""
            for statement in statements {
                functionString += statement.trimmedDescription + "\n"
            }
            let protocolConformance = hasProtocolConformances ? "DynamicMiddlewareProtocol" : "Sendable"
            let name = "OpaqueDynamicMiddleware\(i)"
            let decl = try! StructDeclSyntax.init(.init(stringLiteral: """
            // MARK: \(name)
            \(visibility)struct \(name): \(protocolConformance) {

                \(inlinableAnnotation)
                \(visibility)func customLogic(
                    request: \(requestTypeSyntax),
                    response: inout some DynamicResponseProtocol
                ) throws(MiddlewareError) {
                    do { // TODO: use typed throw
                        \(functionString)
                    } catch {
                        throw .custom("\(name)HandleError;\\(error)")
                    }
                }

                \(inlinableAnnotation)
                \(visibility)func handle(
                    request: \(requestTypeSyntax),
                    response: inout some DynamicResponseProtocol
                ) throws(MiddlewareError) -> Bool {
                    try customLogic(request: &request, response: &response)
                    return true
                }
            }
            """))
            generatedDecls.append(decl)
        }
        return ""
    }()

    var visibility: RouterVisibility {
        #if RouterSettings
        settings.visibility
        #else
        .package
        #endif
    }

    var hasProtocolConformances: Bool {
        #if RouterSettings
        settings.hasProtocolConformances
        #else
        true
        #endif
    }

    var dynamicResponsesAreGeneric: Bool {
        #if RouterSettings
        settings.dynamicResponsesAreGeneric
        #else
        false
        #endif
    }

    var respondersAreComputedProperties: Bool {
        #if RouterSettings
        settings.respondersAreComputedProperties
        #else
        false
        #endif
    }

    let visibilityModifier:DeclModifierSyntax
    let requestTypeSyntax:TypeSyntax

    func routerParameter(isCopyable: Bool, protocolConformances: Bool) -> String {
        if isCopyable {
            if protocolConformances {
                return "some HTTPRouterProtocol"
            } else {
                return "CompiledHTTPRouter._Copyable"
            }
        } else {
            if protocolConformances {
                return "borrowing some NonCopyableHTTPRouterProtocol & ~Copyable"
            } else {
                return "borrowing CompiledHTTPRouter._NonCopyable"
            }
        }
    }

    static func responderParameter(copyable: Bool, dynamic: Bool) -> String {
        if !dynamic {
            if copyable {
                return "some RouteResponderProtocol"
            } else {
                return "borrowing some NonCopyableRouteResponderProtocol & ~Copyable"
            }
        }
        if copyable {
            return "some DynamicRouteResponderProtocol"
        } else {
            return "borrowing some NonCopyableDynamicRouteResponderProtocol & ~Copyable"
        }
    }
}

// MARK: Init
extension RouterStorage {
    #if RouterSettings
    init(
        settings: RouterSettings,
        perfectHashSettings: PerfectHashSettings
    ) {
        self.settings = settings
        self.perfectHashSettings = perfectHashSettings
        visibilityModifier = settings.visibility.modifierDecl
        requestTypeSyntax = settings.requestTypeSyntax
    }
    #else
    init(
        perfectHashSettings: PerfectHashSettings
    ) {
        self.perfectHashSettings = perfectHashSettings
        visibilityModifier = RouterVisibility.package.modifierDecl
        requestTypeSyntax = TypeSyntax(stringLiteral: "HTTPRequest")
    }
    #endif
}

// MARK: Misc

extension RouterStorage {
    mutating func routeGroupsString() -> String {
        guard !routeGroups.isEmpty else { return "" }
        var string = "\n"
        for group in routeGroups {
            string += "\(group),\n"
        }
        string.removeLast(2)
        string += "\n"
        return string
    }

    mutating func dynamicMiddlewareArray() -> [String] {
        var array = [String]()
        if autoGeneratedOpaqueDynamicMiddleware != nil {
            array.append(contentsOf: upgradeExistentialDynamicMiddleware.enumerated().map({ "OpaqueDynamicMiddleware\($0.offset)()" }))
        }
        if !dynamicMiddleware.isEmpty {
            array.append(contentsOf: dynamicMiddleware.map({ "\($0)" }))
        }
        return array
    }
}

// MARK: Route
extension RouterStorage {
    struct Route {
        let startLine:String
        let buffer:SIMD64<UInt8>
        let responder:String

        var path: Substring {
            startLine.split(separator: " ")[1]
        }
        var paths: [Substring] {
            path.split(separator: "/")
        }
    }
}